# 哈希表

> 「哈希表 hash table」，又称「散列表」，其通过建立键 `key` 与值 `value` 之间的映射，实现高效的元素查询。具体而言，我们向哈希表输入一个键 `key` ，则可以在 $O(1)$  时间内获取对应的值 `value` 。



## 1.哈希表常用操作

|          | 数组   | 链表   | 哈希表 |
| -------- | ------ | ------ | ------ |
| 查找元素 | $O(n)$ | $O(n)$ | $O(1)$ |
| 添加元素 | $O(1)$ | $O(1)$ | $O(1)$ |
| 删除元素 | $O(n)$ | $O(n)$ | $O(1)$ |

观察发现，**在哈希表中进行增删查改的时间复杂度都是 $O(1)$** ，非常高效。

```cpp
/* 初始化哈希表 */
unordered_map<int, string> map;

/* 添加操作 */
// 在哈希表中添加键值对 (key, value)
map[12836] = "小哈";
map[15937] = "小啰";
map[16750] = "小算";
map[13276] = "小法";
map[10583] = "小鸭";

/* 查询操作 */
// 向哈希表输入键 key ，得到值 value
string name = map[15937];

/* 删除操作 */
// 在哈希表中删除键值对 (key, value)
map.erase(10583);

/* 遍历哈希表 */
// 遍历键值对 key->value
for (auto kv: map) {
    cout << kv.first << " -> " << kv.second << endl;
}
// 单独遍历键 key
for (auto kv: map) {
    cout << kv.first << endl;
}
// 单独遍历值 value
for (auto kv: map) {
    cout << kv.second << endl;
}
```



## 2.哈希冲突与扩容

由于输入空间远远大于输出空间，因此，理论上一定存在多对一的输出情况，显然，这种情况是不对的，我们将这种情况称为哈希冲突hash collision

当哈希表容量越大，多个key被分配到同一个桶的概率就会降低，冲突就会越少，于是我们可以通过扩容哈希表来减少哈希冲突

「负载因子 load factor」定义为哈希表的元素数量除以桶数量，可以理解为哈希冲突概率，该值越大，哈希冲突发生的概率越大，因为剩下空的桶的数量变少了，新加一个元素就大概率与原来的桶重合
