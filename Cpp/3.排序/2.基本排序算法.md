# 简单的排序算法

[TOC]


## **一、冒泡排序**

### **1、算法思想**

冒泡排序是一种简单的排序算法，通过循环遍历，将临近的两个元素进行比较，满足排序规则时，进行下一组元素对比，当不满足排序规则时，将两个元素交换位置，再继续进行下一组元素对比，确保最大的元素在一遍循环过后一定排在最后面，然后最后通过最多n2次循环对比，直到完全有序。

### **2.算法描述**

[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-iejufrI6-1687923321856)(E:\笔记\c++笔记\cpp.picture\冒泡.gif)]

（1）比较两个相邻的元素，如果第一个比第二个大，那么就交换他们的位置。
（2）重复步骤（1）的操作，依次比较两两相邻的两个元素。所有元素对比过后表示一次循环结束。
（3）至多循环n-1次，重复上面两个步骤。
（4）直到没有任何一组元素需要交换位置表示排序完成。

### **3.代码**

```cpp
void BubbleSort(int* slist,int length)
{
    int temp;
    for (int i = 0; i < length - 1; i++)
    {
        for (int j = 0; j < length - 1 - i; j++)
        {
            if (slist[j] > slist[j + 1])
            {
                temp = slist[j];
                slist[j] = slist[j + 1];
                slist[j + 1] = temp;
            }
        }
    }
}
int main()
{
    int sortlist[] = { 5,0,4,1,8,3,7 };
    BubbleSort(sortlist,7);
}

```



### **4、算法复杂度**

最好的情况为正序，只需要一遍遍历，所以时间复杂度为O(n),最坏的情况为逆序，需要遍历n2次，所以时间复杂度为O(n2)。由于只有一个交换的变量temp需要内存，所以空间复杂度为O(1)。

------



## **二、插入排序**

### **1、算法思想**

将列表中的每个元素依次和之前排好序的元素进行比较，找到合适的位置插入，使之前有序的列表保持依然有序。

### **2、算法描述**

<img src="E:\笔记\c++笔记\cpp.picture\插入.gif" style="zoom:150%;" />

（1）从第2个元素开始，选取第2个元素（i），认为第1个元素为一个只有一个元素的有序列表。
（2）将选取的元素与之前的元素依次比较，如果选取的元素小于于列表中的元素，交换他们的位置。
（3）选取下一个元素（i+1），重复步骤（2），直至列表中的每个元素都进行了步骤（2）的操作。

### **3、代码实现**

```cpp
//方法一
void InsertSort1(int* slist,int length)
{
    int temp;
    for (int i = 1; i < length; i++)
    {
        int j = i -1;
        while (slist[j] > slist[j+1] && j >= 0)
        {
            //交换位置
            temp = slist[j];
            slist[j] = slist[j+1];
            slist[j+1] = temp;
            j--;

            /*或者这样交换*/
            // slist[j+1] = slist[j] + slist[j+1];
            // slist[j] = slist[j+1] - slist[j];
            // slist[j+1] = slist[j+1] - slist[j];
            // j--;
        }
        
    } 
}

//方法二
void InsertSort2(int* slist,int length)
{
    for (int i = 1; i < length; i++)
    {
        int j = i - 1;
        int number = slist[i];
        while (j >= 0 && slist[j] > number)
        {
            slist[j+1] = slist[j];
            j--;
        }
        slist[j+1] = number; 
    } 
}

```

### **4.算法复杂度**

最好的情况为正序，只需要一遍遍历，所以时间复杂度为O(n),最坏的情况为逆序，需要遍历n2次，所以时间复杂度为O(n2)。空间复杂度为O(1)。

------



## **三、选择排序**

### **1、算法思想**

从头开始，遍历列表找到最小值，把最小的值放在第一个位置，在遍历找到第二小的值放在第一个后面，以此类推，知道最后一个排好序。

### **2、算法描述**

[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-pRcZBthE-1687923321857)(E:\笔记\c++笔记\cpp.picture\选择.png)]

（1）遍历整个列表N个元素，找到最小的元素，与第一个元素交换位置。
（2）遍历剩余的N-1个元素，找到最小的元素，将它排在剩余N-1个元素的第一个。
（3）以此类推，重复步骤（2），直到N-1小于1。

### **3、代码实现**

```cpp
void SelectSort(int* slist, int length)
{
    int min;
    int temp;
    for (int i = 0; i < length; i++)
    {
        min = i;
        for (int j = i + 1; j < length; j++)
        {
            if (slist[j] < slist[min])
            {
                min = j;
            }
        }
        temp = slist[i];
        slist[i] = slist[min];
        slist[min] = temp;
    }
}

```

### **4、算法复杂度**

    min = j;
            }
        }
        temp = slist[i];
        slist[i] = slist[min];
        slist[min] = temp;
    }
}

```

### **4、算法复杂度**

不管最后还是最坏的情况，选择排序的时间复杂度都是O(n2)，空间复杂度为O(1)。
